"""
AI service for generating chess preparation plans using Grok API.
"""

import asyncio
import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import aiohttp
import logging
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)


@dataclass
class PrepPlan:
    """Chess preparation plan generated by AI."""
    player_name: str
    opponent_name: str
    tournament_date: Optional[str]
    opening_preparation: List[Dict[str, Any]]
    tactical_themes: List[str]
    strategic_focus: List[str]
    daily_training_plan: List[Dict[str, Any]]
    weakness_exploitation: List[Dict[str, Any]]
    time_control_strategy: Dict[str, str]
    psychological_notes: List[str]
    confidence_score: float  # 0-1 scale
    estimated_prep_time: int  # hours
    created_at: str = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now().isoformat()


class GrokAIService:
    """Service for interacting with xAI's Grok API."""
    
    def __init__(self, api_key: str, base_url: str = "https://api.x.ai/v1"):
        """Initialize Grok AI service."""
        self.api_key = api_key
        self.base_url = base_url
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def __aenter__(self):
        """Async context manager entry."""
        self.session = aiohttp.ClientSession(
            headers={"Authorization": f"Bearer {self.api_key}"},
            timeout=aiohttp.ClientTimeout(total=60)
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        if self.session:
            await self.session.close()
    
    async def _make_request(self, endpoint: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Make request to Grok API."""
        if not self.session:
            raise RuntimeError("GrokAIService must be used as async context manager")
        
        url = f"{self.base_url}/{endpoint}"
        
        try:
            async with self.session.post(url, json=data) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    error_text = await response.text()
                    logger.error(f"Grok API error {response.status}: {error_text}")
                    raise Exception(f"Grok API error: {response.status}")
        
        except aiohttp.ClientError as e:
            logger.error(f"HTTP error calling Grok API: {e}")
            raise
        except Exception as e:
            logger.error(f"Unexpected error calling Grok API: {e}")
            raise
    
    async def generate_prep_plan(self, 
                               player_analysis: Dict[str, Any],
                               opponent_analysis: Dict[str, Any],
                               tournament_info: Optional[Dict[str, Any]] = None) -> PrepPlan:
        """Generate a comprehensive preparation plan."""
        
        # Build the prompt for Grok
        prompt = self._build_prep_plan_prompt(player_analysis, opponent_analysis, tournament_info)
        
        data = {
            "messages": [
                {
                    "role": "system",
                    "content": "You are a world-class chess coach and preparation specialist. Generate detailed, actionable chess preparation plans based on player analysis and opponent research. Provide specific, practical advice that can be implemented in training sessions."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            "model": "grok-beta",
            "temperature": 0.7,
            "max_tokens": 3000
        }
        
        try:
            response = await self._make_request("chat/completions", data)
            
            # Parse the response
            content = response["choices"][0]["message"]["content"]
            prep_plan_data = self._parse_prep_plan_response(content, player_analysis, opponent_analysis)
            
            return PrepPlan(**prep_plan_data)
        
        except Exception as e:
            logger.error(f"Error generating prep plan: {e}")
            # Return a basic prep plan as fallback
            return self._create_fallback_prep_plan(player_analysis, opponent_analysis)
    
    def _build_prep_plan_prompt(self, 
                              player_analysis: Dict[str, Any],
                              opponent_analysis: Dict[str, Any],
                              tournament_info: Optional[Dict[str, Any]] = None) -> str:
        """Build the prompt for generating prep plan."""
        
        prompt = f"""
Generate a comprehensive chess preparation plan for the following matchup:

PLAYER PROFILE:
- Name: {player_analysis.get('player_name', 'Player')}
- Rating: {player_analysis.get('rating', 'Unknown')}
- Playing Strength Assessment: {player_analysis.get('strength_assessment', 'Not available')}

PLAYER'S OPENING REPERTOIRE:
As White: {self._format_openings(player_analysis.get('repertoire', {}).get('as_white', []))}
As Black vs 1.e4: {self._format_openings(player_analysis.get('repertoire', {}).get('as_black_vs_e4', []))}
As Black vs 1.d4: {self._format_openings(player_analysis.get('repertoire', {}).get('as_black_vs_d4', []))}

PLAYER'S WEAKNESSES:
{self._format_weaknesses(player_analysis.get('weaknesses', {}))}

OPPONENT PROFILE:
- Name: {opponent_analysis.get('player_name', 'Opponent')}
- Rating: {opponent_analysis.get('rating', 'Unknown')}
- Playing Strength: {opponent_analysis.get('strength_assessment', 'Not available')}

OPPONENT'S OPENING REPERTOIRE:
As White: {self._format_openings(opponent_analysis.get('repertoire', {}).get('as_white', []))}
As Black vs 1.e4: {self._format_openings(opponent_analysis.get('repertoire', {}).get('as_black_vs_e4', []))}
As Black vs 1.d4: {self._format_openings(opponent_analysis.get('repertoire', {}).get('as_black_vs_d4', []))}

OPPONENT'S WEAKNESSES:
{self._format_weaknesses(opponent_analysis.get('weaknesses', {}))}

TOURNAMENT INFORMATION:
{self._format_tournament_info(tournament_info)}

Please provide a detailed preparation plan in JSON format with the following structure:

{{
    "opening_preparation": [
        {{
            "color": "white/black",
            "opening": "opening name",
            "variation": "specific variation",
            "key_ideas": ["idea1", "idea2"],
            "critical_positions": ["fen1", "fen2"],
            "study_time_hours": 2
        }}
    ],
    "tactical_themes": ["pin", "fork", "discovered_attack"],
    "strategic_focus": ["weak squares", "pawn structure", "piece activity"],
    "daily_training_plan": [
        {{
            "day": 1,
            "focus": "Opening preparation",
            "tasks": ["Study Sicilian Dragon", "Solve 10 tactical puzzles"],
            "duration_hours": 3
        }}
    ],
    "weakness_exploitation": [
        {{
            "opponent_weakness": "weak kingside",
            "exploitation_method": "kingside attack",
            "example_positions": ["fen"],
            "practice_exercises": ["exercise description"]
        }}
    ],
    "time_control_strategy": {{
        "opening": "Play quickly in known theory",
        "middlegame": "Think on critical moments",
        "endgame": "Calculate precisely"
    }},
    "psychological_notes": ["stay calm under pressure", "avoid time trouble"],
    "confidence_score": 0.75,
    "estimated_prep_time": 20
}}
        """
        
        return prompt
    
    def _format_openings(self, openings: List[Dict[str, Any]]) -> str:
        """Format opening repertoire for prompt."""
        if not openings:
            return "No data available"
        
        formatted = []
        for opening in openings[:5]:  # Top 5 most frequent
            name = opening.get('name', 'Unknown')
            frequency = opening.get('frequency', 0)
            win_rate = opening.get('win_rate', 0)
            formatted.append(f"{name} ({frequency} games, {win_rate:.1%} score)")
        
        return "; ".join(formatted)
    
    def _format_weaknesses(self, weaknesses: Dict[str, Any]) -> str:
        """Format weaknesses for prompt."""
        if not weaknesses:
            return "No specific weaknesses identified"
        
        formatted = []
        
        # Blunders by phase
        blunders = weaknesses.get('blunders_by_phase', {})
        if blunders:
            phase_blunders = []
            for phase, count in blunders.items():
                if count > 0:
                    phase_blunders.append(f"{count} in {phase}")
            if phase_blunders:
                formatted.append(f"Blunders: {', '.join(phase_blunders)}")
        
        # Average centipawn loss
        acl = weaknesses.get('average_centipawn_loss_by_phase', {})
        if acl:
            phase_losses = []
            for phase, loss in acl.items():
                if loss > 0:
                    phase_losses.append(f"{phase}: {loss:.0f}cp")
            if phase_losses:
                formatted.append(f"Avg centipawn loss - {', '.join(phase_losses)}")
        
        return "; ".join(formatted) if formatted else "Minor tactical oversights"
    
    def _format_tournament_info(self, tournament_info: Optional[Dict[str, Any]]) -> str:
        """Format tournament information."""
        if not tournament_info:
            return "General preparation (no specific tournament)"
        
        info = []
        if 'name' in tournament_info:
            info.append(f"Tournament: {tournament_info['name']}")
        if 'date' in tournament_info:
            info.append(f"Date: {tournament_info['date']}")
        if 'time_control' in tournament_info:
            info.append(f"Time control: {tournament_info['time_control']}")
        if 'rounds' in tournament_info:
            info.append(f"Rounds: {tournament_info['rounds']}")
        
        return "; ".join(info)
    
    def _parse_prep_plan_response(self, 
                                content: str,
                                player_analysis: Dict[str, Any],
                                opponent_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Parse the AI response into prep plan data."""
        try:
            # Try to extract JSON from the response
            # Look for JSON block in the response
            json_start = content.find('{')
            json_end = content.rfind('}') + 1
            
            if json_start != -1 and json_end != -1:
                json_str = content[json_start:json_end]
                parsed_data = json.loads(json_str)
                
                # Add required fields that might be missing
                prep_plan_data = {
                    'player_name': player_analysis.get('player_name', 'Player'),
                    'opponent_name': opponent_analysis.get('player_name', 'Opponent'),
                    'tournament_date': None,
                    'opening_preparation': parsed_data.get('opening_preparation', []),
                    'tactical_themes': parsed_data.get('tactical_themes', []),
                    'strategic_focus': parsed_data.get('strategic_focus', []),
                    'daily_training_plan': parsed_data.get('daily_training_plan', []),
                    'weakness_exploitation': parsed_data.get('weakness_exploitation', []),
                    'time_control_strategy': parsed_data.get('time_control_strategy', {}),
                    'psychological_notes': parsed_data.get('psychological_notes', []),
                    'confidence_score': parsed_data.get('confidence_score', 0.5),
                    'estimated_prep_time': parsed_data.get('estimated_prep_time', 10)
                }
                
                return prep_plan_data
            
        except (json.JSONDecodeError, KeyError) as e:
            logger.error(f"Error parsing AI response: {e}")
        
        # Fallback: create basic structure from the text response
        return self._parse_text_response(content, player_analysis, opponent_analysis)
    
    def _parse_text_response(self, 
                           content: str,
                           player_analysis: Dict[str, Any],
                           opponent_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Parse non-JSON response into prep plan structure."""
        return {
            'player_name': player_analysis.get('player_name', 'Player'),
            'opponent_name': opponent_analysis.get('player_name', 'Opponent'),
            'tournament_date': None,
            'opening_preparation': [
                {
                    'color': 'white',
                    'opening': 'Main repertoire',
                    'variation': 'Standard lines',
                    'key_ideas': ['Control center', 'Develop pieces'],
                    'critical_positions': [],
                    'study_time_hours': 3
                }
            ],
            'tactical_themes': ['pins', 'forks', 'discovered attacks'],
            'strategic_focus': ['piece activity', 'pawn structure', 'king safety'],
            'daily_training_plan': [
                {
                    'day': 1,
                    'focus': 'Opening preparation',
                    'tasks': ['Study main lines', 'Solve tactical puzzles'],
                    'duration_hours': 3
                }
            ],
            'weakness_exploitation': [
                {
                    'opponent_weakness': 'Time management',
                    'exploitation_method': 'Play complex positions',
                    'example_positions': [],
                    'practice_exercises': ['Complex middlegame positions']
                }
            ],
            'time_control_strategy': {
                'opening': 'Play familiar lines quickly',
                'middlegame': 'Use time on critical decisions',
                'endgame': 'Calculate accurately'
            },
            'psychological_notes': ['Stay confident', 'Trust preparation'],
            'confidence_score': 0.6,
            'estimated_prep_time': 15
        }
    
    def _create_fallback_prep_plan(self, 
                                 player_analysis: Dict[str, Any],
                                 opponent_analysis: Dict[str, Any]) -> PrepPlan:
        """Create a basic prep plan when AI generation fails."""
        return PrepPlan(
            player_name=player_analysis.get('player_name', 'Player'),
            opponent_name=opponent_analysis.get('player_name', 'Opponent'),
            tournament_date=None,
            opening_preparation=[
                {
                    'color': 'white',
                    'opening': 'Main repertoire',
                    'variation': 'Standard approach',
                    'key_ideas': ['Sound development', 'Central control'],
                    'critical_positions': [],
                    'study_time_hours': 2
                }
            ],
            tactical_themes=['basic combinations', 'endgame technique'],
            strategic_focus=['piece coordination', 'pawn structure'],
            daily_training_plan=[
                {
                    'day': 1,
                    'focus': 'Opening review',
                    'tasks': ['Review main lines', 'Tactical training'],
                    'duration_hours': 2
                }
            ],
            weakness_exploitation=[],
            time_control_strategy={
                'opening': 'Follow preparation',
                'middlegame': 'Calculate key variations',
                'endgame': 'Focus on technique'
            },
            psychological_notes=['Play your game', 'Stay focused'],
            confidence_score=0.5,
            estimated_prep_time=10
        )
    
    async def generate_daily_exercises(self, prep_plan: PrepPlan, day: int) -> Dict[str, Any]:
        """Generate specific exercises for a day of preparation."""
        
        prompt = f"""
Based on the following chess preparation plan, generate specific training exercises for day {day}:

Preparation Plan Focus Areas:
- Tactical themes: {', '.join(prep_plan.tactical_themes)}
- Strategic focus: {', '.join(prep_plan.strategic_focus)}
- Opening preparation needed: {len(prep_plan.opening_preparation)} openings

Generate a detailed training session with:
1. Warm-up exercises (15 minutes)
2. Opening study session (45 minutes)
3. Tactical training (30 minutes)
4. Endgame practice (30 minutes)
5. Game analysis (30 minutes)

Provide specific positions, puzzle types, and study materials.
        """
        
        data = {
            "messages": [
                {
                    "role": "system",
                    "content": "You are a chess trainer creating specific daily training sessions. Provide detailed, practical exercises."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            "model": "grok-beta",
            "temperature": 0.6,
            "max_tokens": 1500
        }
        
        try:
            response = await self._make_request("chat/completions", data)
            content = response["choices"][0]["message"]["content"]
            
            return {
                'day': day,
                'session_plan': content,
                'estimated_duration': 150,  # 2.5 hours
                'generated_at': datetime.now().isoformat()
            }
        
        except Exception as e:
            logger.error(f"Error generating daily exercises: {e}")
            return {
                'day': day,
                'session_plan': 'Basic training session: tactical puzzles and opening review',
                'estimated_duration': 120,
                'generated_at': datetime.now().isoformat()
            }
